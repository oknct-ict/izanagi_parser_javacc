//オプション定義
options{
	STATIC=false;
	MULTI=true;
	VISITOR=true;
	NODE_EXTENDS="izanagi.expr.BaseNode";
	DEBUG_PARSER = true;
}

//パーサークラスの定義
PARSER_BEGIN(ExprParser)
package izanagi.expr.parser;
public class ExprParser{
}
PARSER_END(ExprParser)

//トークンの定義
SKIP:
{
	" " | "\r" | "\t" | "\n"
}
TOKEN:
{
		<DIM: "Dim">
	|	<AS: "as">
	|	<IF: "IF">
	|	<THEN: "Then">
	|	<ELSEIF: "ElseIf">
	|	<ELSE: "Else">
	|	<ENDIF: "End If">
	|	<TYPE: ("Integer" | "Float" | "String")>
	|	<IDENTIFIER: (["a"-"z"] | ["A"-"Z"] | "_") (["a"-"z"] | ["A"-"Z"] | ["0"-"9"] | "_")*>
}
TOKEN:
{
		<PLUS : "+">
	|   <MINUS: "-">
	|	<MUL: "*">
	|	<DIV: "/">
	|	<MOD: "%">
	|	<POWER: "^">
	|	<AND: "And">
	|	<OR: "Or">
	|	<NOT: "Not">
	|	<GE: ">=">
	|	<GT: ">">
	|	<LE: "<=">
	|	<LT: "<">
	|	<EQ: "==">
	|	<NEQ: "!=">
	|	<ASSIGN: "=">
	|	<ADDASSIGN: "+=">
	|	<SUBASSIGN: "-=">
	|	<MULASSIGN: "*=">
	|	<DIVASSIGN: "/=">
	|	<MODASSIGN: "%=">
	|	<POWASSIGN: "^=">
	|	<LPAREN: "(">
	|	<RPAREN: ")">
	|	<COMMA: ",">
	|	<STR_START: "\""> : IN_STR
	|   <INTEGER: (["0" - "9"])+>
	|	<FLOAT: (["0" - "9"])+ "." (["0" - "9"])+>
}

<IN_STR> MORE:
{
		<~["\"", "\\", "\n", "\r", "\t"]>
	|	<"\\\"">
			{image.deleteCharAt(image.length() - 2); }
	|	<"\\n" | "\\r">
			{image.delete(image.length() - 2, image.length()); image.append("\n");}
	|	<"\\t">
			{image.delete(image.length() - 2, image.length()); image.append("\t");}
}

<IN_STR> TOKEN:
{
	<STR: "\"">{
		image.deleteCharAt(image.length() - 1);
		matchedToken.image = image.toString();
	} : DEFAULT
}

//文法の定義
ASTStart Start():
{}
{
	Stmts() <EOF> {return jjtThis;}
}

void Stmts():
{}
{
	(Stmt())+
}

void Block():
{}
{
	(Stmt())+
}

void Stmt():
{}
{
		IfStmt() 
	|	DimStmt() 
	|	Expression() 
}

void IfStmt():
{ Token t;}
{
	<IF> <LPAREN> CompExpr() <RPAREN> <THEN>
		Block()
	(<ELSEIF> <LPAREN> CompExpr() <RPAREN> <THEN>
		Block()
	)*
	(<ELSE>
		Block()
	)?
	<ENDIF>
}

void DimStmt():
{ Token t;}
{
	<DIM> Var() <AS> t = <TYPE> {jjtThis.nodeValue = t.image;} 
}

void Var():
{ Token t;}
{
		t = <IDENTIFIER> {jjtThis.nodeValue = t.image;}
}

//void VarArray():
//{}
//{
//	t = <IDENTIFIER> {jjtThis.nodeValue = t.image}
//	<LPAREN> ExpressionList() <RpAREN> 
//}

void ExpressionList() #void:
{}
{
	Expression() (<COMMA> Expression())*
}

void Expression() #void:
{}
{
	AssignExpr()
}

void AssignExpr() #void:
{}
{
	Var() (
				<ASSIGN> EqualCompExpr() #Assign(2)
			|	<ADDASSIGN> EqualCompExpr() #AddAssign(2)
			|	<SUBASSIGN> EqualCompExpr() #SubAssign(2)
			|	<MULASSIGN> EqualCompExpr() #MulAssign(2)
			|	<DIVASSIGN> EqualCompExpr() #DivAssign(2)
			|	<MODASSIGN> EqualCompExpr() #ModAssign(2)
			|	<POWASSIGN> EqualCompExpr() #PowAssign(2) )
}

void CompExpr() #void:
{}
{
	EqualCompExpr()
}

void EqualCompExpr() #void:
{}
{
	SizeCompExpr() (
				<EQ> SizeCompExpr() #Eq(2)
			|	<NEQ> SizeCompExpr() #NEq(2) )*
}

void SizeCompExpr() #void:
{}
{
	AddExpr() (
				<GE> AddExpr() #Ge(2)
			|	<GT> AddExpr() #Gt(2)
			|	<LE> AddExpr() #Le(2)
			|	<LT> AddExpr() #Lt(2) )*
}

void AddExpr() #void:
{}
{
	MulExpr() (
				<PLUS>  MulExpr() #Add(2)
			|   <MINUS> MulExpr() #Sub(2) )*
}

void MulExpr() #void:
{}
{
	UniExpr() (
				<MUL> UniExpr() #Mul(2)
			|	<DIV> UniExpr() #Div(2)
			|	<MOD> UniExpr() #Mod(2)
			|	<POWER> UniExpr() #Power(2)
			|	<AND> UniExpr() #And(2)
			|	<OR> UniExpr() #Or(2)
			|	<NOT> UniExpr() #Not(2) )*
}

void UniExpr():
{ Token t;}
{
		Literal() {jjtThis.nodeValue = "+";}
	|	t = <MINUS> {jjtThis.nodeValue = t.image;} Literal()
}

void Literal() #void:
{}
{
		Integer()
	|	Float()
	|	String()
	|	<LPAREN> AddExpr() <RPAREN>
	|	RefVar()
}

void Integer():
{ Token t;}
{
	t = <INTEGER> { jjtThis.nodeValue = t.image;}
}

void Float():
{ Token t;}
{
	t = <FLOAT> {jjtThis.nodeValue = t.image;}
}

void String():
{ Token t;}
{
	<STR_START>
	t = <STR> {jjtThis.nodeValue = t.image;}
}

void RefVar():
{ Token t;}
{
	t = <IDENTIFIER> {jjtThis.nodeValue = t.image;}
}
